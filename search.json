[{"title":"理解instanceof的背后原理","url":"/2020/10/13/理解instanceof的背后原理/","content":"**概念：**\ninstanceof的作用： 因为利用typeof判断，我们所得到的许多结果都是object，这个时候我们就可以用instanceof来判断\ninstanceof的MDN定义： 判断构建函数的prototype是否在对象的原型链上\n\n所以instanceof 的背后原理其实是是原型链，就是要判断b.prototype是否在a.__proto__上。\n首先，要使用instanceof，我们需要一个对象和一个函数，例如 a instanceof b，a必须为对象，b为函数。\n我们可以先用instanceof判断基本的js类型：\n\n``` javascript\nString instanceof String //false\nString instanceof Object //true   \nFunction instanceof Object //true\nObject instanceof Object //true obj.__proto__ = Object.prototype\n```\n实现一个instanceof\n``` javascript\nfunction instance_of(left,right){\n\tconst RP = right.prototype;\n\twhile(true){\n\t\tif(left === null){\n\t\t \treturn false;\n\t\t\t}\n\t\tif(left === RP){\n\t\t\treturn true;\n\t\t\t}\n\t\t\tleft = left.__proto__;\n\t\t}\n}\n```"},{"title":"认识原型与原型链","url":"/2020/10/13/认识原型与原型链/","content":"**1.概念**\n**prototype与_proto_**\n\n**原型（prototype）**： 每一个函数都有原型prototype，是函数独有的，这个属性是一个指针，指向一个对象，这个对象包含所有构造函数的实例共享的变量与方法\n\n_proto_是每一个对象都有的，它指向它的构造函数的原型，是隐性的\n\n**原型链**： 当我们在对象里查找一个值的时候，js在对象里没有找到的话，就会在对象的原型对象里寻找，如果还是没有找到的话，就会在原型对象的原型对象里寻找，这个过程被委托在原型链当中，原型链的尽头指向Null\n\n**2.认识与理解**\n针对判断原型的指向的题目，记得几个准则：\n一是  _proto_ 指向的是 它构造函数的原型对象，要判断好谁是它的构造函数\n二是 *prototype* 有constructor函数，指向的是自己\n三是js的原型链最终指向的是Object原型对象(Object.prototype)\n``` javascript\nfunction Foo() {}\nconsole.log(Foo.prototype == Foo.prototype)  // true  \nconsole.log(Foo.prototype.constructor == Foo) //true\nconsole.log(Foo.__proto__ == Function.prototype) //true\nconsole.log(Foo.prototype.__proto__ == Object.prototype) //true\n\n```\n\n**3.理解new关键字的过程**\n\n使用new关键字调用函数(new ClassA(...))的具体过程\n1. 创建一个空对象, Var obj={};\n2. 设置新对象的constructor属性为构造函数的名称，将新对象的proto指向构造函数的prototype\nObj.__proto__==ClassA.prototype\n3. 使用新对象调用构造函数，将构造函数中this指向新实例对象，ClassA.call(obj)\n4. 将初始化完毕的新对象地址，保存到等号左边的变量中。\n5. 若构造函数中返回this或返回值是基本类型(number,string,bool,null,undefined)或者无返回值，则返回新的实例对象，若是引用类型的值，则返回这个引用类型。\n\n实例伪代码过程\n\n``` javascript\nnew Person(\"John\") = {\n  var obj = {};\n\tobj.__proto__ = Person.prototype;\n\t// 此时便建立了obj对象的原型链：\n\t// obj->Person.prototype->Object.prototype->null\n\tvar result = Person.call(obj,\"John\"); // 相当于obj.Person(\"John\")\n\t// 如果无返回值或者返回一个非对象值，则将obj返回作为新对象：\n\treturn typeof result === 'object' ? result || obj : obj;\n}\n```\n\n"},{"title":"笔试题1","url":"/2020/10/13/笔试题1/","content":"\n``` javascript\n//笔试题 leecode\n//寻找数组所能组成的最大值\n//原理是 利用冒泡排序，比较两个数的时候，\n// 例如 1，10. 所能组成的情况有 110 101，所以1在10前面。\nfunction bubleSort(arr){\n    return arr.sort( (a,b) => (b+''+a) - (a+''+b)).join('').replace(/^0*/,'') || '0';\n\n}\n\nfunction bubleSort1(arr){\n    for(var i=0; i<arr.length-1; i++){\n        for(var j=0; j<arr.length-i-1;j++){\n            if(arr[j+1] + '' + arr[j] > arr[j]+''+arr[j+1]){\n                let temp =arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                console.log(arr);\n            }\n        }\n    }\n    arr = arr.join('');\n    console.log(arr[0]);\n    if(arr[0] == '0'){\n        return '0';\n    }else{\n        return arr;\n    }\n}\n// leetcode 290\n// 词性匹配 AABB 对应 cat cat dog dog   True\n// AABC  CAT CAT CAT DOG   False\n// 思路： 找出false的情况\n// 利用map, 把pattern和str 一一对应比较。 遍历pattern， 比较pattern[i]和str[i]\n// 假如pattern[i]不在map里，那么false的情况有，str[i]在map的values里\n// 假如pattern[i]在map里， 那么false的情况有， str[i]不等于map[pattern[i]]的值， 其余情况为true\nvar wordPattern = function(pattern, s) {\n    pattern = pattern.split('');\n    s = s.split(' ');\n    if(pattern.length !== s.length){\n        return false;\n    }\n    var dir = {};\n    for(var i=0;i<pattern.length;i++){\n       if(!dir[pattern[i]]){\n           for(var j in dir){\n               if(dir[j] == s[i]){\n                   return false;\n               }\n           }\n           dir[pattern[i]] = s[i];\n       }else{\n           if(dir[pattern[i]] !== s[i]){\n               return false;\n           }\n       }\n    }\n    return true;\n};\n```"},{"title":"MVC和MVVM区别","url":"/2020/10/11/MVC和MVVM区别/","content":"![enter description here](https://fuzhou123.s3.us-east-2.amazonaws.com/MVC+%E4%B8%8E+MVP+%E4%B8%8E+MVVM+%E5%8C%BA%E5%88%AB.png)\n"}]