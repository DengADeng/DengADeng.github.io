[{"title":"react学习之组件与state","url":"/2020/12/01/react学习之组件与state/","content":"\n## 1.  对React组件的理解\n组件是一个具备UI 描述和UI 数据的完整体。\n它的数据结构是类或函数，返回 React 元素。 简单来说，可以把组件看成是一个函数，输入的是 props 和 state，输出的是组件的 UI（UI 描述）\n\n## 2. 创建组件的方式\n\n#### 2.1 函数组件，使用function的组件\n\n``` javascript\nconst Test = (props) => {\n\treturn (\n\t\t<p>test</p>\n\t)\n}\n```\n一般是无状态的,在出了react hook之后，函数组件也可以拥有自己的状态\n\n#### 2.2 class组件（es6）\n可以通过es6 class的方法来实现组件，组件继承react.component，必须拥有render方法，class组件属于有状态的组件。\n\n``` javascript\nimport React extends \"react\"\n\nclass Component extends React.Component {\n    render(){\n        return (\n            <div>我是一个react组件<div>\n        )\n    }\n}\n\n```\n\n## 3. state 与 props\n\n#### 3.1 props的特性\nprops是一个结构简单的对象，props在组件做为JSX属性使用时，是一个可以接收外部数据的接口。\n1.  可以传递数值与函数\n2.  从父组件中传入\n3.  只读\n\n#### 3.2 props只读的原因\nReact 组件间的通信是遵循单向数据流的思想，实现是通过 props。具体表现为数据主要从父组件传递给子组件。如果父组件的传递给子组件的某个 props 改变了，子组件将会重新渲染。\n在子组件中可以通过 this.props 访问到父组件中传进来的数据。根据约定，子组件中不能直接使用 this.props 修改 props。一般来说，我们可以在父组件中定义一个方法用于修改某个状态，然后把该函数通过 props 传入子组件，这样子组件就可以通过调用该函数修改 props\n\n#### 3.3 state\n\nstate是组件的内部状态，代表的是组件 UI 呈现的完整状态集。state 中所有的状态都应反映组件 UI 的变化。\n\nstate 的两种使用场景：\n\n1.  用于渲染组件时用到的数据的来源\n2.  用作组件展示形式的判断依据\n\n#### 3.3.1 关于setState\n\nsetState有两种传参方式\n1.  传入一个对象与回调函数\n2.  传入一个函数与回调函数\n\n``` javascript\nthis.setState({count:1});\n----------------------------------\nthis.setState((prevState, props) => ({\n  counter: prevState.counter + props.increment\n}));\n```\nsetState可以传入两个参数，第一个参数为要修改的对象，传入函数时返回时必须要返回修改完后的对象状态。第二个参数为修改后要调用的回调函数，由于react的机制，setstate不一定是同步的，可能是异步的，这里的异步是说react可能把多个更新state的动作合并成一次进行执行，所以造成异步的现象。如果我们要在setState之后获取state，可能会得不到想要的结果，所以这时候的操作可以在setState的第二个参数（回调函数，等价于componentDidUpdate）里执行。\n\n setState 通过使用Object.assign()方法来合并state，它像是一个异步方法，而实际上 setState 方法并没有直接修改 state，它只是把要修改的状态放入一个队列中，最后由 React 统一把这些修改与当前 state 合并。setState 的更新过程实际上是把当前修改的状态跟当前 state 合并的过程。所以说 setState 是一个异步方法并不准确，只是 state 更新使用的这种批处理机制从而给人一种 setState 方法是一个异步方法的假象。\n\n\n\n"},{"title":"React Jsx学习","url":"/2020/11/30/React-Jsx学习/","content":"\n## Jsx简介\n JSX，是一个 JavaScript 的语法扩展，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。\n\n## 基本语法\n\n### 在Jsx中嵌入js表达式\n在react中，我们可以将js语法和html将结合起来，react认为渲染逻辑本质上与其他 UI 逻辑内在耦合。\n我们可以在jsx中使用js语法，将js语法放在{}中。\n\n例如：\n\n``` javascript\nconst name = 'Josh Perez';\nconst element = <h1>Hello, {name}</h1>;\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n同时，我们也可以放入js函数表达式。\n\n``` javascript\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Harper',\n  lastName: 'Perez'\n};\n\nconst element = (\n  <h1>\n    Hello, {formatName(user)}!\n  </h1>\n);\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n\n### Jsx同时也可以做为JS表达式\n\n在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。\n\n所以，我们可以在js中使用Jsx，例如在if,else表达式中使用。同时，我们也可以将Jsx当作参数使用，设定变量，做回返回等。\n\n``` javascript\nfunction getGreeting(user) {\n  if (user) {\n    return <h1>Hello, {formatName(user)}!</h1>;\n  }\n  return <h1>Hello, Stranger.</h1>;\n}\n```\n\n### Jsx可以包含多个子元素\n\n我们可以在Jsx中设置多个子元素\n\n``` javascript\nconst element = (\n  <div>\n    <h1>Hello!</h1>\n    <h2>Good to see you here.</h2>\n  </div>\n);\n```\n\n### 防止xss攻击\n\n``` javascript\nconst title = response.potentiallyMaliciousInput;\n// 直接使用是安全的：\nconst element = <h1>{title}</h1>\n```\nReact DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。\n\n### JSX 表示对象\n\nBabel 会把 JSX 转译成一个名为 React.createElement() 函数调用。\n\n``` javascript\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n//以上两个代码是等价的\n```\n\n"},{"title":"react lifecycle","url":"/2020/11/30/react-lifecycle/"},{"title":"理解instanceof的背后原理","url":"/2020/10/13/理解instanceof的背后原理/","content":"**概念：**\ninstanceof的作用： 因为利用typeof判断，我们所得到的许多结果都是object，这个时候我们就可以用instanceof来判断\ninstanceof的MDN定义： 判断构建函数的prototype是否在对象的原型链上\n\n所以instanceof 的背后原理其实是是原型链，就是要判断b.prototype是否在a.__proto__上。\n首先，要使用instanceof，我们需要一个对象和一个函数，例如 a instanceof b，a必须为对象，b为函数。\n我们可以先用instanceof判断基本的js类型：\n\n``` javascript\nString instanceof String //false\nString instanceof Object //true   \nFunction instanceof Object //true\nObject instanceof Object //true obj.__proto__ = Object.prototype\n```\n实现一个instanceof\n``` javascript\nfunction instance_of(left,right){\n\tconst RP = right.prototype;\n\twhile(true){\n\t\tif(left === null){\n\t\t \treturn false;\n\t\t\t}\n\t\tif(left === RP){\n\t\t\treturn true;\n\t\t\t}\n\t\t\tleft = left.__proto__;\n\t\t}\n}\n```"},{"title":"认识原型与原型链","url":"/2020/10/13/认识原型与原型链/","content":"**1.概念**\n**prototype与_proto_**\n\n**原型（prototype）**： 每一个函数都有原型prototype，是函数独有的，这个属性是一个指针，指向一个对象，这个对象包含所有构造函数的实例共享的变量与方法\n\n_proto_是每一个对象都有的，它指向它的构造函数的原型，是隐性的\n\n**原型链**： 当我们在对象里查找一个值的时候，js在对象里没有找到的话，就会在对象的原型对象里寻找，如果还是没有找到的话，就会在原型对象的原型对象里寻找，这个过程被委托在原型链当中，原型链的尽头指向Null\n\n**2.认识与理解**\n针对判断原型的指向的题目，记得几个准则：\n一是  _proto_ 指向的是 它构造函数的原型对象，要判断好谁是它的构造函数\n二是 *prototype* 有constructor函数，指向的是自己\n三是js的原型链最终指向的是Object原型对象(Object.prototype)\n``` javascript\nfunction Foo() {}\nconsole.log(Foo.prototype == Foo.prototype)  // true  \nconsole.log(Foo.prototype.constructor == Foo) //true\nconsole.log(Foo.__proto__ == Function.prototype) //true\nconsole.log(Foo.prototype.__proto__ == Object.prototype) //true\n\n```\n\n**3.理解new关键字的过程**\n\n使用new关键字调用函数(new ClassA(...))的具体过程\n1. 创建一个空对象, Var obj={};\n2. 设置新对象的constructor属性为构造函数的名称，将新对象的proto指向构造函数的prototype\nObj.__proto__==ClassA.prototype\n3. 使用新对象调用构造函数，将构造函数中this指向新实例对象，ClassA.call(obj)\n4. 将初始化完毕的新对象地址，保存到等号左边的变量中。\n5. 若构造函数中返回this或返回值是基本类型(number,string,bool,null,undefined)或者无返回值，则返回新的实例对象，若是引用类型的值，则返回这个引用类型。\n\n实例伪代码过程\n\n``` javascript\nnew Person(\"John\") = {\n  var obj = {};\n\tobj.__proto__ = Person.prototype;\n\t// 此时便建立了obj对象的原型链：\n\t// obj->Person.prototype->Object.prototype->null\n\tvar result = Person.call(obj,\"John\"); // 相当于obj.Person(\"John\")\n\t// 如果无返回值或者返回一个非对象值，则将obj返回作为新对象：\n\treturn typeof result === 'object' ? result || obj : obj;\n}\n```\n\n"},{"title":"笔试题1","url":"/2020/10/13/笔试题1/","content":"\n``` javascript\n//笔试题 leecode\n//寻找数组所能组成的最大值\n//原理是 利用冒泡排序，比较两个数的时候，\n// 例如 1，10. 所能组成的情况有 110 101，所以1在10前面。\nfunction bubleSort(arr){\n    return arr.sort( (a,b) => (b+''+a) - (a+''+b)).join('').replace(/^0*/,'') || '0';\n\n}\n\nfunction bubleSort1(arr){\n    for(var i=0; i<arr.length-1; i++){\n        for(var j=0; j<arr.length-i-1;j++){\n            if(arr[j+1] + '' + arr[j] > arr[j]+''+arr[j+1]){\n                let temp =arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                console.log(arr);\n            }\n        }\n    }\n    arr = arr.join('');\n    console.log(arr[0]);\n    if(arr[0] == '0'){\n        return '0';\n    }else{\n        return arr;\n    }\n}\n// leetcode 290\n// 词性匹配 AABB 对应 cat cat dog dog   True\n// AABC  CAT CAT CAT DOG   False\n// 思路： 找出false的情况\n// 利用map, 把pattern和str 一一对应比较。 遍历pattern， 比较pattern[i]和str[i]\n// 假如pattern[i]不在map里，那么false的情况有，str[i]在map的values里\n// 假如pattern[i]在map里， 那么false的情况有， str[i]不等于map[pattern[i]]的值， 其余情况为true\nvar wordPattern = function(pattern, s) {\n    pattern = pattern.split('');\n    s = s.split(' ');\n    if(pattern.length !== s.length){\n        return false;\n    }\n    var dir = {};\n    for(var i=0;i<pattern.length;i++){\n       if(!dir[pattern[i]]){\n           for(var j in dir){\n               if(dir[j] == s[i]){\n                   return false;\n               }\n           }\n           dir[pattern[i]] = s[i];\n       }else{\n           if(dir[pattern[i]] !== s[i]){\n               return false;\n           }\n       }\n    }\n    return true;\n};\n```"},{"title":"MVC和MVVM区别","url":"/2020/10/11/MVC和MVVM区别/","content":"![enter description here](https://fuzhou123.s3.us-east-2.amazonaws.com/MVC+%E4%B8%8E+MVP+%E4%B8%8E+MVVM+%E5%8C%BA%E5%88%AB.png)\n"}]