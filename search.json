[{"title":"二分搜索","url":"/2020/12/10/二分搜索/","content":"\n#### 240. Search a 2D Matrix II\n编写一种有效的算法，在m x n整数矩阵中搜索目标值。矩阵具有以下属性： 每行中的整数按从左到右的升序排列。 每列中的整数按从上到下的升序排列。\n\n``` javascript\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\nOutput: true\n```\n\n``` javascript\n// 思路跟search a 2d matrix I 差不多， 二分搜索从矩阵右上角搜索\n// 通过排除 列，行 的方式来找目标值，时间复杂度 logN.\n// 我们知道当右上角的值比目标值小的时候，我们知道它左边的数不符合要求，因为升序排列，所以我们可以排除它所在的一行,row++\n// 我们知道当右上角的值比目标值大的时候，我们知道它所在的那一列不符合要求，我们可以排除一列，col--\nvar searchMatrix = function(matrix, target) {\n    let row = 0;\n    let col = matrix[0].length - 1;\n    while(row<=matrix.length - 1 && col >= 0){\n        if(matrix[row][col] == target){\n            return true;\n        }else if(matrix[row][col] > target){\n            col --;\n        }else{\n            row ++;\n        }\n    }\n    return false;\n};\n```\n\n#### 162. Find Peak Element\n峰值元素是严格大于其相邻元素的元素。 给定一个整数数组nums，找到一个峰值元素，然后返回其索引。如果阵列包含多个峰，则将索引返回到任何一个峰。\n\n``` javascript\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n```\n\n``` javascript\nvar findPeakElement = function(nums) {\n    // peak     low(上升曲线) peak low（下降曲线）\n    // 峰值左右两边有两个小于它的值，\n    // 当我们遍历数组时，我们用当前数与它的下一个数进行对比，如果我们找到比它小的数，我们可以知道\n    // 他可以构成一个峰值，因为在这过程中我们可以确保他左边的数比他小\n    // 假设有数组[1,2,3,1]，我们遍历数组，比较当前数是否大于下一个数，我们可以知道当到3的时候，我们\n    // 满足要求，同时3也比它左边的数都大，左边的数值构成了一个上升曲线，所以我们不用比较当前数与他前一位数的大小，因为当他不大于他下一个数时，他就构成了一个上升曲线，我们只要找到上升曲线的最高点的数在哪里下降\n    let l = 0;\n    let r = nums.length - 1;\n    while(l<r){\n        let mid = Math.floor((l+r)/2);\n        if(nums[mid] < nums[mid+1]){\n            l = mid + 1;\n        }else{\n            r = mid;\n        }\n    }\n    return l;\n};\n```\n\n#### 167. Two Sum II - Input array is sorted\n给定一个已经按升序排序的整数数组，请找到两个数字，使它们加起来成为一个特定的目标数字。 函数twoSum应该返回两个数字的索引，以使它们加起来等于目标，其中index1必须小于index2。\n\n``` javascript\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.\n```\n\n``` javascript\n//TwoSum的题，可以用map来做，一边记录一边确认\n// 也可以做双指针来做，前后搜索\n//这里用二分搜索来做，时间复杂度为nlogn。\n//思路为遍历数组，利用二分搜索来寻找是否有target-arr[i]。\nvar twoSum = function(numbers, target) {\n    \n    for(let i=0; i<numbers.length; i++){\n        let l = i+ 1;\n        let r = numbers.length - 1;\n        while(l<=r){\n            let mid = Math.floor((l+r)/2);\n            let temp = target-numbers[i];\n            if(numbers[mid] == temp){\n                return [i+1,mid+1];\n            }else if(numbers[mid] > temp){\n                r = mid - 1;\n            }else{\n                l = mid + 1;\n            }\n        }\n    }\n};\n```\n\n####  Find Minimum in Rotated Sorted Array II\n假设以升序排序的数组在事先未知的某个轴上旋转。\n（即[0,1,2,4,5,6,7]可能会变成[4,5,6,7,0,1,2]）。 \n找到最小的元素。 该数组可能包含重复项。\n\n``` javascript\nInput: [1,3,5]\nOutput: 1\n\nInput: [2,2,2,0,1]\nOutput: 0\n```\n\n``` javascript\n//Find Minimum in Rotated Sorted Array I的解法是用二分搜索找到中间值，然后跟最后一位数比较，确认中间值是否处于乱序，然后进行二分搜索。\n//这题的思路也是一样的，不同的是遇到一样的值，直接消去就行，把同样的值消去，就变成跟 I 一样了。\nvar findMin = function(nums) {\n    let l = 0;\n    let r = nums.length - 1;\n    while(l<r){\n        let mid = Math.floor((l+r)/2);\n        if(nums[mid] > nums[r]){\n            l = mid + 1;\n        }else if(nums[mid] < nums[r]){\n            r = mid;\n        }else{\n            r--;\n        }\n    }\n    return nums[l];\n};\n```"},{"title":"leetcode 二分查找","url":"/2020/12/07/leetcode-二分查找/","content":"\n一个简单的二分查找：\n\n``` javascript\nfunction binarySearch(arr,target,l,r){\n\twhile(l<=r){\n\t\tlet mid = Math.floor((l+r)/2);\n\t\tif(arr[mid] == target){\n\t\t\treturn mid;\n\t\t}else if(arr[mid] > target){\n\t\t    r = mid-1;\n\t\t}else{\n\t\t    l = mid+1;\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n#### 480. Sliding Window Median\n给定一个数组num，存在一个大小为k的滑动窗口，该窗口从数组的最左边移到最右边。您只能在窗口中看到k个数字。每次滑动窗口向右移动一个位置。您的工作是输出原始数组中每个窗口的中值数组。\n\n``` javascript\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\n\nWindow position                Median\n---------------               -----\n[1  3  -1] -3  5  3  6  7       1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7       3\n 1  3  -1  -3 [5  3  6] 7       5\n 1  3  -1  -3  5 [3  6  7]      6\n```\n思路： 维持一个有序数组，例如第一次的窗口数组为[1,3,-1],我们可以把它先进行排序变成[-1,1,3]。\n\n接下来对于要进来的数字，我们要进行的操作是，删除在window里原有nums数组的第一个数值，在window里插入nums数组中接下来的数字，同时保证数组有序。\n这个部分我们可以用二分查找来做，删除操作时可以在logN的时间内找到，添加数字时，由于数组中没有这个数字，但是l,r的位置会锁定添加数字的位置。\n\n时间复杂度为nlogN,暴力解法复杂度为N^2，因为每次都要进行排序;\n代码：\n\n``` javascript\nvar medianSlidingWindow = function(nums, k) {\n\n    let start = 0, end = k-1;\n    let res = [];\n    let window = nums.slice(start,end+1);\n    window.sort((a,b) => a-b);\n    //console.log(window);\n    while(end<nums.length){\n        let len = window.length;\n        let median = k%2 === 0? (window[Math.floor(k / 2) - 1] + window[Math.floor(k / 2)]) / 2\n        : window[Math.floor(k / 2)];\n        res.push(median);\n        //console.log(res,'res');\n        // remove first element of nums in window\n        let remove = nums[start++];\n        let removeIndex = binarySearch(0,len-1,window,remove);\n        window.splice(removeIndex,1);\n        //console.log(window);\n        // add next element of nums\n        let add = nums[++end];\n        let addIndex = binarySearch(0,len-1,window,add);\n        window.splice(addIndex,0,add);\n            \n    }\n    return res;\n\n    function binarySearch(l,r,arr,target){\n        while(l<r){\n            let mid = Math.floor((l+r)/2);\n            if(arr[mid] == target){\n                return mid\n            }else if(arr[mid] > target){\n                r = mid\n            }else{\n                l = mid + 1\n            }\n        }\n        if(l === r) return arr[l] >= target? l: l+1;\n}\n};\n```\n\n#### 74. Search a 2D Matrix\n写一种有效的算法，以在m x n矩阵中搜索值。该矩阵具有以下属性： 每行中的整数从左到右排序。 每行的第一个整数大于前一行的最后一个整数。\n\n``` javascript\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 3\nOutput: true\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 13\nOutput: false\n```\n二分搜索的典型题目，假设我们有m*n 的矩阵,有两种思路：\n1. 一种是我们可以从矩阵最右上角的值进行判断,row=0,col=matrix[0].length-1，matirx[row][col]==target, 大于的话， col--, 小于的话 row++.\n2.  第二个方法是把矩阵看成数组的形式，matrix ==> arr ===>matrix[mid/m]][mid%m], m为一行的长度，比如matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]]， 我们可以看成长度为12的数组，mid=Math.floor((l+r)/2) // ==>5, 那么中间值的位置为matrix[5/4][5%4] ==> matrix[1][1]\n\n代码：\n\n``` javascript\n\nvar searchMatrix = function(matrix, target) {\n    if (!matrix.length || !matrix[0].length) return false;\n    let row = 0;\n    let col = matrix[0].length - 1;\n    while(col>=0 && row<matrix.length){\n        console.log(row,col);\n        if(matrix[row][col] === target){\n            return true;\n        }else if(matrix[row][col] > target){\n            col--;\n        }else{\n            row++;\n        }\n    }\n    return false;\n};\n\nvar searchMatrix = function(matrix, target) {\n    if (!matrix.length || !matrix[0].length) return false;\n    let m = matrix[0].length;\n    let n = matrix.length;\n    let l = 0;\n    let r = m*n-1;\n    while(l<=r){\n        let mid = Math.floor((l+r)/2);\n        //console.log(matrix[Math.floor(mid/m)][mid%m],mid, l,r);\n        if(matrix[Math.floor(mid/m)][mid%m] == target){\n            return true;\n        }else if(matrix[Math.floor(mid/m)][mid%m] > target){\n            r = mid - 1;\n        }else{\n            l = mid + 1;\n        }\n    }\n    return false;\n};\n```"},{"title":"滑动窗口2","url":"/2020/12/06/滑动窗口2/","content":"\n### 395. Longest Substring with At Least K Repeating Characters\n\n给定字符串s和整数k，返回s的最长子字符串的长度，以使该子字符串中每个字符的频率大于或等于k。\n\n``` javascript\nInput: s = \"aaabb\", k = 3\nOutput: 3\nExplanation: The longest substring is \"aaa\", as 'a' is repeated 3 times.\n\nInput: s = \"ababbc\", k = 2\nOutput: 5\nExplanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\n\n```\n\n思路：\n我们要找到最长子字符串，使得该子字符串中每个字符的频率大于或等于k。\n假设我们有字符串  s=ababbc, k=2.\n这题用滑动窗口来解决，我们要找到在不断增长窗口的情况下，什么条件下停止缩小窗口。\n我们知道a->b->a->b->b是满足k=2的最优解。\n我们可以先设定start，end=0; \n在这过程中，我们一开始不知道有字符串中有几种字符串满足条件,假设最大的不同字符串的个数为MaxU，那么我们开始从a开始，设定窗口里只允许有一种字符串，从第一个字符a开始扩大窗口，直到遇到b时，我们缩小窗口，从窗口里找出满足a的频率满足k的结果，用窗口扫描字符串。然后我们可以假设两种字符的情况‘ab'，在窗口里有'ab'时，不断增大窗口，直到窗口遇到’c‘，找出’a‘和’b‘的频率满足k的结果。窗口从小到大增加字符串的类型，这样我们能得到所有的结果。\n\n代码：\n``` javascript\nvar longestSubstring = function(s, k) {\n    let maxU = new Set(s).size;   //字符串最多的不同\n    let res = 0;\n    //console.log(maxU);\n    for(let curU = 1; curU<=maxU; curU++){   //按最多的次数遍历，即从设定窗口满足curU个字符种类\n        let atLeastU = 0, u=0, start=0, end=0, window={};\n        //console.log(1);\n        while(end<s.length){\n            let temp = s[end];\n            window[temp] = window[temp]+1||1;   //窗口记录当前值\n            if(window[temp] == 1) u++;    //u代表当前窗口里有u个种类字符串\n            if(window[temp] == k) atLeastU++;  //atLeastU增加，当窗口种字符满足k\n            \n            //console.log(u,atLeastU,curU,window,res)\n            while(u>curU){         //遇到不同字符，缩小窗口，缩小u\n                let temp1 = s[start];\n                window[temp1] = window[temp1]-1;\n                if(window[temp1] == k-1) atLeastU--;\n                if(window[temp1] == 0) u--;\n                start++;\n            }\n            \n            if(u == curU && u == atLeastU){  //代表当前窗口满足窗口中所有字符的频率大于等于k\n                res = Math.max(res, end-start+1);\n            }\n            end++;\n        }\n    }\n    return res;\n};\n```\n\n### 239. Sliding Window Maximum\n\n您将得到一个整数数组，其中有一个大小为k的滑动窗口，该窗口从数组的最左边移到最右边。您只能在窗口中看到k个数字。每次滑动窗口向右移动一个位置。返回最大的窗口值。\n\n``` javascript\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]\nExplanation: \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n思路： 这题可以用单调栈来做，用暴力解法的时间复杂度很高。\n``` javascript\n针对1,3,-1,-3,5,3,6,7]，我们可以设立一个栈,栈里不断添加值，当当前值大于栈里最后的元素时，不断清空栈的第一个元素，直到清空栈。如果栈的长度等于k时，我们知道栈头的元素是最大的，拿出栈里第一个元素。具体过程如下：\n\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3     \n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n \n \n Window position                Max\n ---------------               -----\n [1]                             --\n [3]                             --\n [3,-1] \t\t\t\t\t\t3   ==》此时，窗口的长度已经为3，此时为第一次的窗口\n [3,-1,-3]\t\t\t\t\t    3\n [5]\t\t\t\t\t\t\t5\n [5,3]\t\t\t\t\t\t\t5\n [6]\t\t\t\t\t\t    6\n [7]\t\t\t\t\t\t\t7\n```\n\n``` javascript\nconst maxSlidingWindow = (nums, k) => {\n  const res = [];\n  const q = [];\n\n  for (let i = 0; i < nums.length; i++) {\n    while (q.length - 1 >= 0 && nums[i] > q[q.length - 1]) q.pop();\n    q.push(nums[i]);\n\n    // When i + 1 - k >= 0, the window is fully overlapping nums\n    const j = i + 1 - k;\n    if (j >= 0) {\n      res.push(q[0]);\n      if (nums[j] === q[0]) q.shift(); // If the biggest element in q is about to exit window, remove it from q\n    }\n  }\n  return res;\n};\n```"},{"title":"leetcode滑动窗口问题详解","url":"/2020/12/03/leetcode滑动窗口问题详解/","content":"\n### 1. 滑动窗口框架\n滑动窗口其实是双指针组成的一个检索窗口，思路为右指针不断扩大窗口，直到窗口满足特定的条件，然后增大左指针缩小窗口来锁定最优解。\n\n通用框架为：\n\n``` javascript\nfunction slidingWindow(s,target){\n   let left = 0, right = 0;\n   while(right<s.length){\n      window.add(s[right]) // 增加右指针，增大窗口\n\t  right++;\n\t  \n\t  if(vallid){    //满足条件\n\t     window.remove(s[left])   //增加左指针，减小窗口\n\t\t left++;                // 在这过程中锁定res\n\t  }\n   }\n}\n```\n### 2. leetcode 题目\n\n#### 2.1 76. Minimum Window Substring\n\n在一个字符串中找出拥有所有目标字符串字母的最短字符串，简而言之，找出一个最短的字符串包含所有t字符串的字母。\n``` javascript\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\n\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\n```\n思路是：\n1. 我们先设立一个map，把target字符串出现的字符和字符次数依次记录，设count=0,count表示target.size()。\n2. 设立window窗口为另一个map，把target中的字符串输入，次数为0，目的是判断当前窗口是否包含了所有的字符串，当所有的次数为1时，我们知道，窗口满足条件。\n3. left=right=0, 先增大right,扩大窗口window，使得窗口中包含所有t的字符，我们可以通过map.has(s[right])来判断当前字符是否在t里，然后我们可以判断map(s[right]) == window[s[right])， 如果成立，count++. \n4.  当count==target.size()时，我们知道，所有的子串都包含在当前窗口了，我们需要缩小窗口，所以我们需要增大左指针，缩小窗口，找到满足条件的最优解。\n\n代码：\n\n``` javascript\nvar minWindow = function(s, t) {\n    let window = {};  //设两个map，一个为窗口，一个为target\n    let needs = {};\n    for(let i of t){\n        if(needs[i]){    // needs里记录t中的字符串\n            needs[i] +=1\n        }else{\n            needs[i] = 1;\n        }\n        \n        window[i] = 0;\n    }\n    let match = 0 // 记录匹配的次数，当match==need.size()时，说明当前窗口满足拥有所有t中的字符串\n    \n    let left = right = 0;\n    \n    let res = Infinity;\n    \n    let start = 0;\n    while(right < s.length){\n        let rightStr = s[right];\n        if(needs[rightStr] >= 1){    //判断当前字符串是否为目标字符串中的字符\n            //console.log(rightStr);\n            window[rightStr] += 1;    //是的话，窗口记录\n            if(window[rightStr] == needs[rightStr]){  //当窗口记录的次数与needs的次数相同，match++，因为考虑有重复的字符，所以要保证次数相同\n                match += 1;\n            }\n            console.log(window,needs,match)\n        }\n        right++;\n        \n        while(match == Object.keys(needs).length){ //满足条件\n            if(right - left < res){     // 找到res,比较当前字符串长度是否最小，最小为答案\n                start = left;\n                res = right-left;\n            }    \n            let leftStr = s[left];\n            if(needs[leftStr]){    \n                window[leftStr] -= 1;  //缩小窗口\n                if(needs[leftStr] > window[leftStr]){\n                    match -=1;\n                }\n            }\n            left ++;   \n        }\n    }\n    return res==Infinity? \"\":s.substr(start,res);\n};\n```\n\n#### 2.2  Longest Substring Without Repeating Characters\n给定字符串s，找到最长子字符串的长度而不重复字符。\n\n``` javascript\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n代码：\n\n``` javascript\nvar lengthOfLongestSubstring = function(s) {\n    let str = '';   // 记录当前窗口的str\n    let index = 0;  \n    let res = 0;\n    for(let i=0; i<s.length; i++){\n        let temp = s[i];   //遍历\n        \n        index = str.indexOf(temp);  // 当前窗口的str中是否包含重复\n        if(index > -1){                     // 重复， 删去重复的部分，从重复的下一个坐标开始\n            str = str.substring(index+1)\n        }\n        \n        str += s[i];                         // 不重复，不断扩大\n        res = Math.max(res, str.length);   // 过程中，判断最长的长度\n    }\n    return res;\n};\n```\n套用框架的写法：\n\n``` javascript\nvar lengthOfLongestSubstring = function(s) {\n    let left = right = 0;\n    let res = 0;\n    let window = {};\n    while(right<s.length){\n        let temp = s[right];\n        if(window[temp]){    //记录次数\n            window[temp] += 1;\n        }else{\n            window[temp] = 1;\n        }\n        \n        right++;\n        \n        while(window[temp] > 1){ //当窗口中的某些字符的次数超过1\n            let temp1 = s[left];           // 缩小窗口\n            window[temp1] -= 1;\n            left++;\n        }\n        \n        res = Math.max(res, right-left);\n    }\n    \n    return res;\n};\n\n```\n#### 2.3 Find All Anagrams in a String\n给定字符串s和非空字符串p，在s中找到p的字谜的所有起始索引。\n\n``` javascript\nInput:\ns: \"cbaebabacd\" p: \"abc\"\n\nOutput:\n[0, 6]\n\nExplanation:\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\"\n```\n\n代码：\n套用框架，思路相同，扩大窗口，使得窗口中含有所有p，然后使match == p.length，就知道当前窗口包含所有p,缩小窗口，如果right-left= p.length，说明找到了包含所有p的起始位置\n``` javascript\nvar findAnagrams = function(s, p) {\n    let left = right = 0;\n    let window = {};\n    let needs = {};\n    let match = 0;\n    let res = [];\n    for(let i of p){\n        if(needs[i]){\n            needs[i] += 1;\n        }else{\n            needs[i] = 1;\n        }\n        window[i] = 0;\n    }\n    \n    while(right<s.length){\n        let ltemp = s[right];\n        if(needs[ltemp] >= 1){\n            window[ltemp] += 1;\n            if(window[ltemp] == needs[ltemp]){\n                match += 1;\n            }\n        }\n        right++;\n        \n        while(match == Object.keys(needs).length){\n            if(right - left == p.length){\n                res.push(left);\n            }\n            let leftStr = s[left];\n            if(needs[leftStr]){\n                window[leftStr] -= 1;\n                if(needs[leftStr] > window[leftStr]){\n                    match -=1;\n                }\n            }\n            left ++;\n        }\n    }\n    return res;\n};\n```\n\n#### 3.4 567. Permutation in String\n给定两个字符串s1和s2，如果s2包含s1的排列，则编写一个函数以返回true。换句话说，第一个字符串的排列之一是第二个字符串的子字符串.\n\n``` javascript\nInput: s1 = \"ab\" s2 = \"eidbaooo\"\nOutput: True\nExplanation: s2 contains one permutation of s1 (\"ba\").\n```\n思路与上一题相同。\n``` javascript\nvar checkInclusion = function(s1, s2) {\n    if(!s1 || !s2 || s1.length > s2.length) return false;\n    let left = 0,\n        right = 0,\n        map = {};\n    for(let i of s1){\n        if(map[i]){\n            map[i] += 1;\n        }else{\n            map[i] = 1;\n        }\n    }\n    let count = Object.keys(map).length;\n    //console.log(map);\n    while(right<s2.length){\n        let temp = s2[right];\n        //console.log(temp,map[temp]);\n        if(map.hasOwnProperty(temp)){\n            map[temp] -= 1;\n            if(map[temp] == 0){\n                count --;\n                \n            }\n        }\n        \n        right++;\n        //console.log(map)\n        while(count == 0 ){\n            let temp1 = s2[left];\n            if(map.hasOwnProperty(temp1)){\n                map[temp1] += 1;\n                if(map[temp1]>0) count++;\n            }\n            if(right-left == s1.length) return true;\n            left++;\n        }\n    }\n    return false;\n};\n```"},{"title":"react学习之组件与state","url":"/2020/12/01/react学习之组件与state/","content":"\n## 1.  对React组件的理解\n组件是一个具备UI 描述和UI 数据的完整体。\n它的数据结构是类或函数，返回 React 元素。 简单来说，可以把组件看成是一个函数，输入的是 props 和 state，输出的是组件的 UI（UI 描述）\n\n## 2. 创建组件的方式\n\n#### 2.1 函数组件，使用function的组件\n\n``` javascript\nconst Test = (props) => {\n\treturn (\n\t\t<p>test</p>\n\t)\n}\n```\n一般是无状态的,在出了react hook之后，函数组件也可以拥有自己的状态\n\n#### 2.2 class组件（es6）\n可以通过es6 class的方法来实现组件，组件继承react.component，必须拥有render方法，class组件属于有状态的组件。\n\n``` javascript\nimport React extends \"react\"\n\nclass Component extends React.Component {\n    render(){\n        return (\n            <div>我是一个react组件<div>\n        )\n    }\n}\n\n```\n\n## 3. state 与 props\n\n#### 3.1 props的特性\nprops是一个结构简单的对象，props在组件做为JSX属性使用时，是一个可以接收外部数据的接口。\n1.  可以传递数值与函数\n2.  从父组件中传入\n3.  只读\n\n#### 3.2 props只读的原因\nReact 组件间的通信是遵循单向数据流的思想，实现是通过 props。具体表现为数据主要从父组件传递给子组件。如果父组件的传递给子组件的某个 props 改变了，子组件将会重新渲染。\n在子组件中可以通过 this.props 访问到父组件中传进来的数据。根据约定，子组件中不能直接使用 this.props 修改 props。一般来说，我们可以在父组件中定义一个方法用于修改某个状态，然后把该函数通过 props 传入子组件，这样子组件就可以通过调用该函数修改 props\n\n#### 3.3 state\n\nstate是组件的内部状态，代表的是组件 UI 呈现的完整状态集。state 中所有的状态都应反映组件 UI 的变化。\n\nstate 的两种使用场景：\n\n1.  用于渲染组件时用到的数据的来源\n2.  用作组件展示形式的判断依据\n\n#### 3.3.1 关于setState\n\nsetState有两种传参方式\n1.  传入一个对象与回调函数\n2.  传入一个函数与回调函数\n\n``` javascript\nthis.setState({count:1});\n----------------------------------\nthis.setState((prevState, props) => ({\n  counter: prevState.counter + props.increment\n}));\n```\nsetState可以传入两个参数，第一个参数为要修改的对象，传入函数时返回时必须要返回修改完后的对象状态。第二个参数为修改后要调用的回调函数，由于react的机制，setstate不一定是同步的，可能是异步的，这里的异步是说react可能把多个更新state的动作合并成一次进行执行，所以造成异步的现象。如果我们要在setState之后获取state，可能会得不到想要的结果，所以这时候的操作可以在setState的第二个参数（回调函数，等价于componentDidUpdate）里执行。\n\n setState 通过使用Object.assign()方法来合并state，它像是一个异步方法，而实际上 setState 方法并没有直接修改 state，它只是把要修改的状态放入一个队列中，最后由 React 统一把这些修改与当前 state 合并。setState 的更新过程实际上是把当前修改的状态跟当前 state 合并的过程。所以说 setState 是一个异步方法并不准确，只是 state 更新使用的这种批处理机制从而给人一种 setState 方法是一个异步方法的假象。\n\n\n\n"},{"title":"React Jsx学习","url":"/2020/11/30/React-Jsx学习/","content":"\n## Jsx简介\n JSX，是一个 JavaScript 的语法扩展，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。\n\n## 基本语法\n\n### 在Jsx中嵌入js表达式\n在react中，我们可以将js语法和html将结合起来，react认为渲染逻辑本质上与其他 UI 逻辑内在耦合。\n我们可以在jsx中使用js语法，将js语法放在{}中。\n\n例如：\n\n``` javascript\nconst name = 'Josh Perez';\nconst element = <h1>Hello, {name}</h1>;\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n同时，我们也可以放入js函数表达式。\n\n``` javascript\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Harper',\n  lastName: 'Perez'\n};\n\nconst element = (\n  <h1>\n    Hello, {formatName(user)}!\n  </h1>\n);\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n\n### Jsx同时也可以做为JS表达式\n\n在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。\n\n所以，我们可以在js中使用Jsx，例如在if,else表达式中使用。同时，我们也可以将Jsx当作参数使用，设定变量，做回返回等。\n\n``` javascript\nfunction getGreeting(user) {\n  if (user) {\n    return <h1>Hello, {formatName(user)}!</h1>;\n  }\n  return <h1>Hello, Stranger.</h1>;\n}\n```\n\n### Jsx可以包含多个子元素\n\n我们可以在Jsx中设置多个子元素\n\n``` javascript\nconst element = (\n  <div>\n    <h1>Hello!</h1>\n    <h2>Good to see you here.</h2>\n  </div>\n);\n```\n\n### 防止xss攻击\n\n``` javascript\nconst title = response.potentiallyMaliciousInput;\n// 直接使用是安全的：\nconst element = <h1>{title}</h1>\n```\nReact DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。\n\n### JSX 表示对象\n\nBabel 会把 JSX 转译成一个名为 React.createElement() 函数调用。\n\n``` javascript\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n//以上两个代码是等价的\n```\n\n"},{"title":"react lifecycle","url":"/2020/11/30/react-lifecycle/"},{"title":"理解instanceof的背后原理","url":"/2020/10/13/理解instanceof的背后原理/","content":"**概念：**\ninstanceof的作用： 因为利用typeof判断，我们所得到的许多结果都是object，这个时候我们就可以用instanceof来判断\ninstanceof的MDN定义： 判断构建函数的prototype是否在对象的原型链上\n\n所以instanceof 的背后原理其实是是原型链，就是要判断b.prototype是否在a.__proto__上。\n首先，要使用instanceof，我们需要一个对象和一个函数，例如 a instanceof b，a必须为对象，b为函数。\n我们可以先用instanceof判断基本的js类型：\n\n``` javascript\nString instanceof String //false\nString instanceof Object //true   \nFunction instanceof Object //true\nObject instanceof Object //true obj.__proto__ = Object.prototype\n```\n实现一个instanceof\n``` javascript\nfunction instance_of(left,right){\n\tconst RP = right.prototype;\n\twhile(true){\n\t\tif(left === null){\n\t\t \treturn false;\n\t\t\t}\n\t\tif(left === RP){\n\t\t\treturn true;\n\t\t\t}\n\t\t\tleft = left.__proto__;\n\t\t}\n}\n```"},{"title":"认识原型与原型链","url":"/2020/10/13/认识原型与原型链/","content":"**1.概念**\n**prototype与_proto_**\n\n**原型（prototype）**： 每一个函数都有原型prototype，是函数独有的，这个属性是一个指针，指向一个对象，这个对象包含所有构造函数的实例共享的变量与方法\n\n_proto_是每一个对象都有的，它指向它的构造函数的原型，是隐性的\n\n**原型链**： 当我们在对象里查找一个值的时候，js在对象里没有找到的话，就会在对象的原型对象里寻找，如果还是没有找到的话，就会在原型对象的原型对象里寻找，这个过程被委托在原型链当中，原型链的尽头指向Null\n\n**2.认识与理解**\n针对判断原型的指向的题目，记得几个准则：\n一是  _proto_ 指向的是 它构造函数的原型对象，要判断好谁是它的构造函数\n二是 *prototype* 有constructor函数，指向的是自己\n三是js的原型链最终指向的是Object原型对象(Object.prototype)\n``` javascript\nfunction Foo() {}\nconsole.log(Foo.prototype == Foo.prototype)  // true  \nconsole.log(Foo.prototype.constructor == Foo) //true\nconsole.log(Foo.__proto__ == Function.prototype) //true\nconsole.log(Foo.prototype.__proto__ == Object.prototype) //true\n\n```\n\n**3.理解new关键字的过程**\n\n使用new关键字调用函数(new ClassA(...))的具体过程\n1. 创建一个空对象, Var obj={};\n2. 设置新对象的constructor属性为构造函数的名称，将新对象的proto指向构造函数的prototype\nObj.__proto__==ClassA.prototype\n3. 使用新对象调用构造函数，将构造函数中this指向新实例对象，ClassA.call(obj)\n4. 将初始化完毕的新对象地址，保存到等号左边的变量中。\n5. 若构造函数中返回this或返回值是基本类型(number,string,bool,null,undefined)或者无返回值，则返回新的实例对象，若是引用类型的值，则返回这个引用类型。\n\n实例伪代码过程\n\n``` javascript\nnew Person(\"John\") = {\n  var obj = {};\n\tobj.__proto__ = Person.prototype;\n\t// 此时便建立了obj对象的原型链：\n\t// obj->Person.prototype->Object.prototype->null\n\tvar result = Person.call(obj,\"John\"); // 相当于obj.Person(\"John\")\n\t// 如果无返回值或者返回一个非对象值，则将obj返回作为新对象：\n\treturn typeof result === 'object' ? result || obj : obj;\n}\n```\n\n"},{"title":"笔试题1","url":"/2020/10/13/笔试题1/","content":"\n``` javascript\n//笔试题 leecode\n//寻找数组所能组成的最大值\n//原理是 利用冒泡排序，比较两个数的时候，\n// 例如 1，10. 所能组成的情况有 110 101，所以1在10前面。\nfunction bubleSort(arr){\n    return arr.sort( (a,b) => (b+''+a) - (a+''+b)).join('').replace(/^0*/,'') || '0';\n\n}\n\nfunction bubleSort1(arr){\n    for(var i=0; i<arr.length-1; i++){\n        for(var j=0; j<arr.length-i-1;j++){\n            if(arr[j+1] + '' + arr[j] > arr[j]+''+arr[j+1]){\n                let temp =arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                console.log(arr);\n            }\n        }\n    }\n    arr = arr.join('');\n    console.log(arr[0]);\n    if(arr[0] == '0'){\n        return '0';\n    }else{\n        return arr;\n    }\n}\n// leetcode 290\n// 词性匹配 AABB 对应 cat cat dog dog   True\n// AABC  CAT CAT CAT DOG   False\n// 思路： 找出false的情况\n// 利用map, 把pattern和str 一一对应比较。 遍历pattern， 比较pattern[i]和str[i]\n// 假如pattern[i]不在map里，那么false的情况有，str[i]在map的values里\n// 假如pattern[i]在map里， 那么false的情况有， str[i]不等于map[pattern[i]]的值， 其余情况为true\nvar wordPattern = function(pattern, s) {\n    pattern = pattern.split('');\n    s = s.split(' ');\n    if(pattern.length !== s.length){\n        return false;\n    }\n    var dir = {};\n    for(var i=0;i<pattern.length;i++){\n       if(!dir[pattern[i]]){\n           for(var j in dir){\n               if(dir[j] == s[i]){\n                   return false;\n               }\n           }\n           dir[pattern[i]] = s[i];\n       }else{\n           if(dir[pattern[i]] !== s[i]){\n               return false;\n           }\n       }\n    }\n    return true;\n};\n```"},{"title":"MVC和MVVM区别","url":"/2020/10/11/MVC和MVVM区别/","content":"![enter description here](https://fuzhou123.s3.us-east-2.amazonaws.com/MVC+%E4%B8%8E+MVP+%E4%B8%8E+MVVM+%E5%8C%BA%E5%88%AB.png)\n"}]