[{"title":"leetcode滑动窗口问题详解","url":"/2020/12/03/leetcode滑动窗口问题详解/","content":"\n### 1. 滑动窗口框架\n滑动窗口其实是双指针组成的一个检索窗口，思路为右指针不断扩大窗口，直到窗口满足特定的条件，然后增大左指针缩小窗口来锁定最优解。\n\n通用框架为：\n\n``` javascript\nfunction slidingWindow(s,target){\n   let left = 0, right = 0;\n   while(right<s.length){\n      window.add(s[right]) // 增加右指针，增大窗口\n\t  right++;\n\t  \n\t  if(vallid){    //满足条件\n\t     window.remove(s[left])   //增加左指针，减小窗口\n\t\t left++;                // 在这过程中锁定res\n\t  }\n   }\n}\n```\n### 2. leetcode 题目\n\n#### 2.1 76. Minimum Window Substring\n\n在一个字符串中找出拥有所有目标字符串字母的最短字符串，简而言之，找出一个最短的字符串包含所有t字符串的字母。\n``` javascript\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\n\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\n```\n思路是：\n1. 我们先设立一个map，把target字符串出现的字符和字符次数依次记录，设count=0,count表示target.size()。\n2. 设立window窗口为另一个map，把target中的字符串输入，次数为0，目的是判断当前窗口是否包含了所有的字符串，当所有的次数为1时，我们知道，窗口满足条件。\n3. left=right=0, 先增大right,扩大窗口window，使得窗口中包含所有t的字符，我们可以通过map.has(s[right])来判断当前字符是否在t里，然后我们可以判断map(s[right]) == window[s[right])， 如果成立，count++. \n4.  当count==target.size()时，我们知道，所有的子串都包含在当前窗口了，我们需要缩小窗口，所以我们需要增大左指针，缩小窗口，找到满足条件的最优解。\n\n代码：\n\n``` javascript\nvar minWindow = function(s, t) {\n    let window = {};  //设两个map，一个为窗口，一个为target\n    let needs = {};\n    for(let i of t){\n        if(needs[i]){    // needs里记录t中的字符串\n            needs[i] +=1\n        }else{\n            needs[i] = 1;\n        }\n        \n        window[i] = 0;\n    }\n    let match = 0 // 记录匹配的次数，当match==need.size()时，说明当前窗口满足拥有所有t中的字符串\n    \n    let left = right = 0;\n    \n    let res = Infinity;\n    \n    let start = 0;\n    while(right < s.length){\n        let rightStr = s[right];\n        if(needs[rightStr] >= 1){    //判断当前字符串是否为目标字符串中的字符\n            //console.log(rightStr);\n            window[rightStr] += 1;    //是的话，窗口记录\n            if(window[rightStr] == needs[rightStr]){  //当窗口记录的次数与needs的次数相同，match++，因为考虑有重复的字符，所以要保证次数相同\n                match += 1;\n            }\n            console.log(window,needs,match)\n        }\n        right++;\n        \n        while(match == Object.keys(needs).length){ //满足条件\n            if(right - left < res){     // 找到res,比较当前字符串长度是否最小，最小为答案\n                start = left;\n                res = right-left;\n            }    \n            let leftStr = s[left];\n            if(needs[leftStr]){    \n                window[leftStr] -= 1;  //缩小窗口\n                if(needs[leftStr] > window[leftStr]){\n                    match -=1;\n                }\n            }\n            left ++;   \n        }\n    }\n    return res==Infinity? \"\":s.substr(start,res);\n};\n```\n\n#### 2.2  Longest Substring Without Repeating Characters\n给定字符串s，找到最长子字符串的长度而不重复字符。\n\n``` javascript\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n代码：\n\n``` javascript\nvar lengthOfLongestSubstring = function(s) {\n    let str = '';   // 记录当前窗口的str\n    let index = 0;  \n    let res = 0;\n    for(let i=0; i<s.length; i++){\n        let temp = s[i];   //遍历\n        \n        index = str.indexOf(temp);  // 当前窗口的str中是否包含重复\n        if(index > -1){                     // 重复， 删去重复的部分，从重复的下一个坐标开始\n            str = str.substring(index+1)\n        }\n        \n        str += s[i];                         // 不重复，不断扩大\n        res = Math.max(res, str.length);   // 过程中，判断最长的长度\n    }\n    return res;\n};\n```\n套用框架的写法：\n\n``` javascript\nvar lengthOfLongestSubstring = function(s) {\n    let left = right = 0;\n    let res = 0;\n    let window = {};\n    while(right<s.length){\n        let temp = s[right];\n        if(window[temp]){    //记录次数\n            window[temp] += 1;\n        }else{\n            window[temp] = 1;\n        }\n        \n        right++;\n        \n        while(window[temp] > 1){ //当窗口中的某些字符的次数超过1\n            let temp1 = s[left];           // 缩小窗口\n            window[temp1] -= 1;\n            left++;\n        }\n        \n        res = Math.max(res, right-left);\n    }\n    \n    return res;\n};\n\n```\n#### 2.3 Find All Anagrams in a String\n给定字符串s和非空字符串p，在s中找到p的字谜的所有起始索引。\n\n``` javascript\nInput:\ns: \"cbaebabacd\" p: \"abc\"\n\nOutput:\n[0, 6]\n\nExplanation:\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\"\n```\n\n代码：\n套用框架，思路相同，扩大窗口，使得窗口中含有所有p，然后使match == p.length，就知道当前窗口包含所有p,缩小窗口，如果right-left= p.length，说明找到了包含所有p的起始位置\n``` javascript\nvar findAnagrams = function(s, p) {\n    let left = right = 0;\n    let window = {};\n    let needs = {};\n    let match = 0;\n    let res = [];\n    for(let i of p){\n        if(needs[i]){\n            needs[i] += 1;\n        }else{\n            needs[i] = 1;\n        }\n        window[i] = 0;\n    }\n    \n    while(right<s.length){\n        let ltemp = s[right];\n        if(needs[ltemp] >= 1){\n            window[ltemp] += 1;\n            if(window[ltemp] == needs[ltemp]){\n                match += 1;\n            }\n        }\n        right++;\n        \n        while(match == Object.keys(needs).length){\n            if(right - left == p.length){\n                res.push(left);\n            }\n            let leftStr = s[left];\n            if(needs[leftStr]){\n                window[leftStr] -= 1;\n                if(needs[leftStr] > window[leftStr]){\n                    match -=1;\n                }\n            }\n            left ++;\n        }\n    }\n    return res;\n};\n```\n\n#### 3.4 567. Permutation in String\n给定两个字符串s1和s2，如果s2包含s1的排列，则编写一个函数以返回true。换句话说，第一个字符串的排列之一是第二个字符串的子字符串.\n\n``` javascript\nInput: s1 = \"ab\" s2 = \"eidbaooo\"\nOutput: True\nExplanation: s2 contains one permutation of s1 (\"ba\").\n```\n思路与上一题相同。\n``` javascript\nvar checkInclusion = function(s1, s2) {\n    if(!s1 || !s2 || s1.length > s2.length) return false;\n    let left = 0,\n        right = 0,\n        map = {};\n    for(let i of s1){\n        if(map[i]){\n            map[i] += 1;\n        }else{\n            map[i] = 1;\n        }\n    }\n    let count = Object.keys(map).length;\n    //console.log(map);\n    while(right<s2.length){\n        let temp = s2[right];\n        //console.log(temp,map[temp]);\n        if(map.hasOwnProperty(temp)){\n            map[temp] -= 1;\n            if(map[temp] == 0){\n                count --;\n                \n            }\n        }\n        \n        right++;\n        //console.log(map)\n        while(count == 0 ){\n            let temp1 = s2[left];\n            if(map.hasOwnProperty(temp1)){\n                map[temp1] += 1;\n                if(map[temp1]>0) count++;\n            }\n            if(right-left == s1.length) return true;\n            left++;\n        }\n    }\n    return false;\n};\n```"},{"title":"react学习之组件与state","url":"/2020/12/01/react学习之组件与state/","content":"\n## 1.  对React组件的理解\n组件是一个具备UI 描述和UI 数据的完整体。\n它的数据结构是类或函数，返回 React 元素。 简单来说，可以把组件看成是一个函数，输入的是 props 和 state，输出的是组件的 UI（UI 描述）\n\n## 2. 创建组件的方式\n\n#### 2.1 函数组件，使用function的组件\n\n``` javascript\nconst Test = (props) => {\n\treturn (\n\t\t<p>test</p>\n\t)\n}\n```\n一般是无状态的,在出了react hook之后，函数组件也可以拥有自己的状态\n\n#### 2.2 class组件（es6）\n可以通过es6 class的方法来实现组件，组件继承react.component，必须拥有render方法，class组件属于有状态的组件。\n\n``` javascript\nimport React extends \"react\"\n\nclass Component extends React.Component {\n    render(){\n        return (\n            <div>我是一个react组件<div>\n        )\n    }\n}\n\n```\n\n## 3. state 与 props\n\n#### 3.1 props的特性\nprops是一个结构简单的对象，props在组件做为JSX属性使用时，是一个可以接收外部数据的接口。\n1.  可以传递数值与函数\n2.  从父组件中传入\n3.  只读\n\n#### 3.2 props只读的原因\nReact 组件间的通信是遵循单向数据流的思想，实现是通过 props。具体表现为数据主要从父组件传递给子组件。如果父组件的传递给子组件的某个 props 改变了，子组件将会重新渲染。\n在子组件中可以通过 this.props 访问到父组件中传进来的数据。根据约定，子组件中不能直接使用 this.props 修改 props。一般来说，我们可以在父组件中定义一个方法用于修改某个状态，然后把该函数通过 props 传入子组件，这样子组件就可以通过调用该函数修改 props\n\n#### 3.3 state\n\nstate是组件的内部状态，代表的是组件 UI 呈现的完整状态集。state 中所有的状态都应反映组件 UI 的变化。\n\nstate 的两种使用场景：\n\n1.  用于渲染组件时用到的数据的来源\n2.  用作组件展示形式的判断依据\n\n#### 3.3.1 关于setState\n\nsetState有两种传参方式\n1.  传入一个对象与回调函数\n2.  传入一个函数与回调函数\n\n``` javascript\nthis.setState({count:1});\n----------------------------------\nthis.setState((prevState, props) => ({\n  counter: prevState.counter + props.increment\n}));\n```\nsetState可以传入两个参数，第一个参数为要修改的对象，传入函数时返回时必须要返回修改完后的对象状态。第二个参数为修改后要调用的回调函数，由于react的机制，setstate不一定是同步的，可能是异步的，这里的异步是说react可能把多个更新state的动作合并成一次进行执行，所以造成异步的现象。如果我们要在setState之后获取state，可能会得不到想要的结果，所以这时候的操作可以在setState的第二个参数（回调函数，等价于componentDidUpdate）里执行。\n\n setState 通过使用Object.assign()方法来合并state，它像是一个异步方法，而实际上 setState 方法并没有直接修改 state，它只是把要修改的状态放入一个队列中，最后由 React 统一把这些修改与当前 state 合并。setState 的更新过程实际上是把当前修改的状态跟当前 state 合并的过程。所以说 setState 是一个异步方法并不准确，只是 state 更新使用的这种批处理机制从而给人一种 setState 方法是一个异步方法的假象。\n\n\n\n"},{"title":"React Jsx学习","url":"/2020/11/30/React-Jsx学习/","content":"\n## Jsx简介\n JSX，是一个 JavaScript 的语法扩展，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。\n\n## 基本语法\n\n### 在Jsx中嵌入js表达式\n在react中，我们可以将js语法和html将结合起来，react认为渲染逻辑本质上与其他 UI 逻辑内在耦合。\n我们可以在jsx中使用js语法，将js语法放在{}中。\n\n例如：\n\n``` javascript\nconst name = 'Josh Perez';\nconst element = <h1>Hello, {name}</h1>;\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n同时，我们也可以放入js函数表达式。\n\n``` javascript\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Harper',\n  lastName: 'Perez'\n};\n\nconst element = (\n  <h1>\n    Hello, {formatName(user)}!\n  </h1>\n);\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n\n### Jsx同时也可以做为JS表达式\n\n在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。\n\n所以，我们可以在js中使用Jsx，例如在if,else表达式中使用。同时，我们也可以将Jsx当作参数使用，设定变量，做回返回等。\n\n``` javascript\nfunction getGreeting(user) {\n  if (user) {\n    return <h1>Hello, {formatName(user)}!</h1>;\n  }\n  return <h1>Hello, Stranger.</h1>;\n}\n```\n\n### Jsx可以包含多个子元素\n\n我们可以在Jsx中设置多个子元素\n\n``` javascript\nconst element = (\n  <div>\n    <h1>Hello!</h1>\n    <h2>Good to see you here.</h2>\n  </div>\n);\n```\n\n### 防止xss攻击\n\n``` javascript\nconst title = response.potentiallyMaliciousInput;\n// 直接使用是安全的：\nconst element = <h1>{title}</h1>\n```\nReact DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。\n\n### JSX 表示对象\n\nBabel 会把 JSX 转译成一个名为 React.createElement() 函数调用。\n\n``` javascript\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n//以上两个代码是等价的\n```\n\n"},{"title":"react lifecycle","url":"/2020/11/30/react-lifecycle/"},{"title":"理解instanceof的背后原理","url":"/2020/10/13/理解instanceof的背后原理/","content":"**概念：**\ninstanceof的作用： 因为利用typeof判断，我们所得到的许多结果都是object，这个时候我们就可以用instanceof来判断\ninstanceof的MDN定义： 判断构建函数的prototype是否在对象的原型链上\n\n所以instanceof 的背后原理其实是是原型链，就是要判断b.prototype是否在a.__proto__上。\n首先，要使用instanceof，我们需要一个对象和一个函数，例如 a instanceof b，a必须为对象，b为函数。\n我们可以先用instanceof判断基本的js类型：\n\n``` javascript\nString instanceof String //false\nString instanceof Object //true   \nFunction instanceof Object //true\nObject instanceof Object //true obj.__proto__ = Object.prototype\n```\n实现一个instanceof\n``` javascript\nfunction instance_of(left,right){\n\tconst RP = right.prototype;\n\twhile(true){\n\t\tif(left === null){\n\t\t \treturn false;\n\t\t\t}\n\t\tif(left === RP){\n\t\t\treturn true;\n\t\t\t}\n\t\t\tleft = left.__proto__;\n\t\t}\n}\n```"},{"title":"认识原型与原型链","url":"/2020/10/13/认识原型与原型链/","content":"**1.概念**\n**prototype与_proto_**\n\n**原型（prototype）**： 每一个函数都有原型prototype，是函数独有的，这个属性是一个指针，指向一个对象，这个对象包含所有构造函数的实例共享的变量与方法\n\n_proto_是每一个对象都有的，它指向它的构造函数的原型，是隐性的\n\n**原型链**： 当我们在对象里查找一个值的时候，js在对象里没有找到的话，就会在对象的原型对象里寻找，如果还是没有找到的话，就会在原型对象的原型对象里寻找，这个过程被委托在原型链当中，原型链的尽头指向Null\n\n**2.认识与理解**\n针对判断原型的指向的题目，记得几个准则：\n一是  _proto_ 指向的是 它构造函数的原型对象，要判断好谁是它的构造函数\n二是 *prototype* 有constructor函数，指向的是自己\n三是js的原型链最终指向的是Object原型对象(Object.prototype)\n``` javascript\nfunction Foo() {}\nconsole.log(Foo.prototype == Foo.prototype)  // true  \nconsole.log(Foo.prototype.constructor == Foo) //true\nconsole.log(Foo.__proto__ == Function.prototype) //true\nconsole.log(Foo.prototype.__proto__ == Object.prototype) //true\n\n```\n\n**3.理解new关键字的过程**\n\n使用new关键字调用函数(new ClassA(...))的具体过程\n1. 创建一个空对象, Var obj={};\n2. 设置新对象的constructor属性为构造函数的名称，将新对象的proto指向构造函数的prototype\nObj.__proto__==ClassA.prototype\n3. 使用新对象调用构造函数，将构造函数中this指向新实例对象，ClassA.call(obj)\n4. 将初始化完毕的新对象地址，保存到等号左边的变量中。\n5. 若构造函数中返回this或返回值是基本类型(number,string,bool,null,undefined)或者无返回值，则返回新的实例对象，若是引用类型的值，则返回这个引用类型。\n\n实例伪代码过程\n\n``` javascript\nnew Person(\"John\") = {\n  var obj = {};\n\tobj.__proto__ = Person.prototype;\n\t// 此时便建立了obj对象的原型链：\n\t// obj->Person.prototype->Object.prototype->null\n\tvar result = Person.call(obj,\"John\"); // 相当于obj.Person(\"John\")\n\t// 如果无返回值或者返回一个非对象值，则将obj返回作为新对象：\n\treturn typeof result === 'object' ? result || obj : obj;\n}\n```\n\n"},{"title":"笔试题1","url":"/2020/10/13/笔试题1/","content":"\n``` javascript\n//笔试题 leecode\n//寻找数组所能组成的最大值\n//原理是 利用冒泡排序，比较两个数的时候，\n// 例如 1，10. 所能组成的情况有 110 101，所以1在10前面。\nfunction bubleSort(arr){\n    return arr.sort( (a,b) => (b+''+a) - (a+''+b)).join('').replace(/^0*/,'') || '0';\n\n}\n\nfunction bubleSort1(arr){\n    for(var i=0; i<arr.length-1; i++){\n        for(var j=0; j<arr.length-i-1;j++){\n            if(arr[j+1] + '' + arr[j] > arr[j]+''+arr[j+1]){\n                let temp =arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                console.log(arr);\n            }\n        }\n    }\n    arr = arr.join('');\n    console.log(arr[0]);\n    if(arr[0] == '0'){\n        return '0';\n    }else{\n        return arr;\n    }\n}\n// leetcode 290\n// 词性匹配 AABB 对应 cat cat dog dog   True\n// AABC  CAT CAT CAT DOG   False\n// 思路： 找出false的情况\n// 利用map, 把pattern和str 一一对应比较。 遍历pattern， 比较pattern[i]和str[i]\n// 假如pattern[i]不在map里，那么false的情况有，str[i]在map的values里\n// 假如pattern[i]在map里， 那么false的情况有， str[i]不等于map[pattern[i]]的值， 其余情况为true\nvar wordPattern = function(pattern, s) {\n    pattern = pattern.split('');\n    s = s.split(' ');\n    if(pattern.length !== s.length){\n        return false;\n    }\n    var dir = {};\n    for(var i=0;i<pattern.length;i++){\n       if(!dir[pattern[i]]){\n           for(var j in dir){\n               if(dir[j] == s[i]){\n                   return false;\n               }\n           }\n           dir[pattern[i]] = s[i];\n       }else{\n           if(dir[pattern[i]] !== s[i]){\n               return false;\n           }\n       }\n    }\n    return true;\n};\n```"},{"title":"MVC和MVVM区别","url":"/2020/10/11/MVC和MVVM区别/","content":"![enter description here](https://fuzhou123.s3.us-east-2.amazonaws.com/MVC+%E4%B8%8E+MVP+%E4%B8%8E+MVVM+%E5%8C%BA%E5%88%AB.png)\n"}]